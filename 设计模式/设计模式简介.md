# 设计模式

## 一、设计模式的本质

构建 **可复用** 的 **面向对象** 软件。
通过抽象出 **优秀实践模型**，作为设计工具，提高软件的可复用性、可扩展性、可维护性。
</br></br>

## 二、设计模式原则

- 开放闭合
- 单一职责
- 里氏替换
- 依赖倒置
- 迪米特法则
- 接口隔离
</br></br>

## 三、设计模式分类

### 创建型模式

- **工厂方法**
  - 定义一个用于创建对象的接口，让子类决定实例化哪一个类。（使一个类的实例化延迟到子类）
</br></br>

- **抽象工厂**
  - 提供一个接口，以创建一系列相关、或互相依赖的对象，而无需制定他们具体的类。
</br></br>

- **单例**
  - 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
</br></br>

- **生成器**
  - 将一个复杂对象的构建与其表示分离，使得同样的构建过程，可以创建不同的表示。
</br></br>

- **原型**
  - 用原型实例制定创建对象的种类，并通过拷贝这些原型，创建新的对象。
</br></br>

### 结构性模式

- **适配器**
  - 将一个类的接口，转换成客户希望的另一个接口。（使得原本接口不兼容的类能够一起工作）
</br></br>

- **装饰器**
  - 动态地给一个对象添加一些额外的职责。（就增加功能来说，相比生成子类更为灵活）
</br></br>

- **桥接**
  - 将抽象部分与他的实现部分分离，使它们可以独立的变化。
</br></br>

- **组合**
  - 将对象组合成树形结构，以表示“部分-整体”的层次结构。（使得用户对单个对象和组合对象的使用具有一致性）
</br></br>

- **外观**
  - 为子系统中的一组接口，提供一个一致的界面。（该模式定义了一个高层接口，使得这一子系统更加容易使用）
</br></br>

- **代理**
  - 为其它对象提供一种代理，以控制对这个对象的访问。
</br></br>

- **享元**
  - 运用共享技术，有效地支持大量细粒度的对象。
</br></br>

### 行为型模式

- **责任链**
  - 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。（将这些对象连成一条链，沿着这条链传递该请求，直到有一个对象处理它为止）
</br></br>

- **迭代器**
  - 提供一种方法，顺序访问聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
</br></br>

- **观察者**
  - 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并被自动更新。
</br></br>

- **访问者**
  - 表示一个作用于某对象结构中各个元素的操作。（使得可以在不改变各元素类的前提下，定义作用于这些元素的新操作）
</br></br>

- **命令**
  - 将一个请求封装为一个对象，从而使你可用不同的请求，对客户进行参数化、对请求排队、或记录请求日志、以及支持可撤销的操作。
</br></br>

- **状态**
  - 允许一个对象在其内部状态改变时，改变它的行为。（看起来像修改了它的类）
</br></br>

- **策略**
  - 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。（使得算法可独立于使用它的客户而变化）
</br></br>

- **模板方法**
  - 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。（使得子类可以不改变一个算法的结构，即可重定义该算法中的某些特定步骤）
</br></br>

- **中介者**
  - 用一个中介对象，来封装一系列的对象交互。（使得各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立的改变它们之间的交互）
</br></br>

- **备忘录**
  - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。（使得恢复对象状态成为可能）
</br></br>

- **解释器**
  - 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
</br></br>
